from _typeshed import Incomplete
from collections.abc import Iterator
from dataclasses import dataclass
from datetime import date, datetime, time, timedelta
from enum import Enum
from functools import cache
from icalendar import Calendar, Event
from pathlib import Path
from typing import Any, NamedTuple, Self
from urllib.parse import ParseResult as ParseResult, urlparse as urlparse

CONF_FILE: Incomplete
logger: Incomplete

class CalEvent(NamedTuple):
    calendar: Calendar
    event: Event

def get_conf(filepath: Path = ...) -> dict[str, Any]: ...
def get_calendars(calendar_name: str | None = None) -> dict[str, Calendar]: ...
def get_events(start: date, end: date, collated: bool = True, calendar_name: str | None = None) -> Iterator[CalEvent]: ...

class Duration(NamedTuple):
    start: time | datetime
    end: time | datetime
    def __contains__(self, other: time | datetime | Self) -> bool: ...
    def __and__(self, other): ...
    def __or__(self, other): ...
    def duration(self): ...
    @classmethod
    def create(cls, start_hour: int, end_hour: int, start_minute: int = 0, end_minute: int = 0): ...

@dataclass
class Event:
    title: str
    start: datetime
    end: datetime
    description: str = ...
    @property
    @cache
    def duration(self) -> Duration: ...
    @classmethod
    def get_from_calendars(cls, start: datetime, end: datetime) -> Iterator: ...

class TIME_OF_DAY(Enum):
    OVERNIGHT_MORNING = ...
    EARLY_MORNING = ...
    MIDMORNING = ...
    MORNING = ...
    LATE_MORNING = ...
    NOON = ...
    EARLY_AFTERNOON = ...
    AFTERNOON = ...
    LATE_AFTERNOON = ...
    EARLY_EVENING = ...
    EVENING = ...
    LATE_EVENING = ...
    NIGHT = ...
    EVENING_AND_NIGHT = EVENING | NIGHT
    @property
    def start(self): ...
    @property
    def end(self): ...
    def __contains__(self, other: datetime | time | Duration) -> bool: ...
    def match(self, time: datetime | time, duration: timedelta | int | None = None) -> bool: ...

@dataclass
class RoutineTime:
    weekdays: frozenset[int]
    time_of_day: TIME_OF_DAY | time
    weeks: frozenset[int] | None = ...
    @classmethod
    def load(cls, in_dict): ...
    def match(self, day: date | datetime | int, time: time | datetime | int, week: int | None = None, duration: timedelta | int | None = None) -> bool: ...

@dataclass
class Task:
    title: str
    description: str = ...
    due: date | datetime = ...
    routine_time: RoutineTime = ...
    def __post_init__(self) -> None: ...
    @classmethod
    def load(cls, in_dict): ...

def tasks_by_routine_day_and_time(tasks: list[Task], valid_times: list[TIME_OF_DAY] | None = None) -> dict[int, set[Task]]: ...
def get_tasks(tasks: list[Task], date: date, time_of_day: TIME_OF_DAY | None = None, remove_routine: bool = False) -> Iterator[Task]: ...
def get_month_tasks(tasks: list[Task], date: date, remove_routine: bool = True) -> Iterator[Task]: ...
