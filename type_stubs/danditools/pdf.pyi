from _typeshed import Incomplete
from dataclasses import dataclass as dataclass, field as field
from enum import StrEnum
from pathlib import Path, PurePath
from pydoc import Doc as Doc
from pypdf import PageObject as PageObject, PdfWriter
from src.dandiscribe.layout import Page as Page
from typing import Callable, Iterator, NamedTuple

def copy_cache(to_dec, deep: bool = True) -> Callable: ...
def extant_path_type(source: str) -> PurePath: ...

class Edge(StrEnum):
    LONG = ...
    SHORT = ...
    VERTICAL = ...
    HORIZONTAL = ...

@copy_cache
def get_pages(source: Path) -> list[PageObject]: ...

class Vector2(NamedTuple):
    x: float
    y: float

class SplitRes(NamedTuple):
    offset: Vector2
    edge: Edge
    dims: Dimensions

class Dimensions(NamedTuple):
    width: float
    height: float
    def split_on_edge(self, edge: Edge = ..., out_edge: Edge | None = None) -> SplitRes: ...

class PageDimensions(NamedTuple):
    width: float
    height: float
    page: PageObject
    ppi: int = ...
    page_num: int | None = ...
    original_page_num: int | None = ...
    @classmethod
    def create_from_page(cls, page: PageObject, page_num: int | None = None) -> PageDimensions: ...
    def get_dimensions(self) -> Dimensions: ...
    def in_inches(self, ppi: int | None = None): ...
    def split_on_edge(self, writer: PdfWriter, edge: str = 'long') -> tuple['PageDimensions', 'PageDimensions']: ...
    @classmethod
    def create_from_pages(cls, pages: list[PageObject]) -> Iterator['PageDimensions']: ...

def crop_page(page: PageObject, dims: PageDimensions, offset: Vector2 = ...): ...

class CantDetermineDimensions(Exception):
    possible_dimensions: Incomplete
    def __init__(self, possible_dimensions: list[Dimensions]) -> None: ...

class DocDimensions(NamedTuple):
    first: Dimensions | None
    body: dict[Dimensions, list[PageDimensions]]
    last: Dimensions | None
    ordered_body: list[PageDimensions] | None = ...
    def guess_best_dims(self, split_on_edge: Edge = ...) -> SplitRes: ...
    def get_needs_split_or_crop(self, dims: Dimensions | None = None): ...
    @classmethod
    def create(cls, source: Path) -> DocDimensions: ...

def split_and_merge(sources: list[Path], dest: Path, dims: Dimensions | None = None, rotation: int | None = None) -> PdfWriter: ...
def dims_type(in_val): ...
def demo() -> None: ...
def split() -> None: ...
